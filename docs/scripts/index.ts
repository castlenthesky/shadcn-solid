import { existsSync, mkdirSync } from "node:fs";
import fs from "node:fs/promises";
import { tmpdir } from "node:os";
import path from "node:path";
import { rimraf } from "rimraf";
import { Project, ScriptKind, SyntaxKind } from "ts-morph";
import * as v from "valibot";
import { fixImport } from "./import";
import { registry } from "./utils";
import { frameworks } from "./utils/frameworks";
import {
	type Registry,
	type registryItemTypeSchema,
	registrySchema,
} from "./utils/schema";

const REGISTRY_PATH = path.join(process.cwd(), "public/registry");

const REGISTRY_INDEX_WHITELIST: v.InferInput<typeof registryItemTypeSchema>[] =
	[
		"registry:ui",
		"registry:libs",
		"registry:hook",
		"registry:theme",
		"registry:block",
		"registry:example",
	];

const project = new Project({
	compilerOptions: {},
});

async function createTempSourceFile(filename: string) {
	const dir = await fs.mkdtemp(path.join(tmpdir(), "shadcn-"));
	return path.join(dir, filename);
}

// ----------------------------------------------------------------------------
// Build __registry__/index.tsx.
// ----------------------------------------------------------------------------
async function buildRegistry(registry: Registry) {
	let index = `// @ts-nocheck
// This file is autogenerated by scripts/index.ts
// Do not edit this file directly.
import { clientOnly } from "@solidjs/start"
  
export const Index: Record<string, any> = {
  `;

	for (const framework of frameworks) {
		// we don't render any of component or example of `unocss`
		if (framework.name === "unocss") {
			break;
		}

		index += ` "${framework.name}": {`;

		// Build style index.
		for (const item of registry) {
			// we only need `example` and `block`
			if (item.type === "registry:example" || item.type === "registry:block") {
				const resolveFiles = item.files?.map(
					(file) =>
						`../packages/${framework.name}/${
							typeof file === "string" ? file : file.path
						}`,
				);
				if (!resolveFiles) {
					continue;
				}

				const type = item.type.split(":")[1];
				let sourceFilename = "";

				const chunks: any = [];
				if (item.type === "registry:block") {
					const file = resolveFiles[0];
					const filename = path.basename(file);
					let raw: string;
					try {
						raw = fixImport(await fs.readFile(file, "utf8"));
					} catch {
						continue;
					}

					const tempFile = await createTempSourceFile(filename);
					const sourceFile = project.createSourceFile(tempFile, raw, {
						scriptKind: ScriptKind.TSX,
					});

					const description = sourceFile
						.getVariableDeclaration("description")
						?.getInitializerOrThrow()
						.asKindOrThrow(SyntaxKind.StringLiteral)
						.getLiteralValue();

					item.description = description ?? "";

					// Find all imports.
					const imports = new Map<
						string,
						{
							module: string;
							text: string;
							isDefault?: boolean;
						}
					>();
					for (const node of sourceFile.getImportDeclarations()) {
						const module = node.getModuleSpecifier().getLiteralValue();
						for (const item of node.getNamedImports()) {
							imports.set(item.getText(), {
								module,
								text: node.getText(),
							});
						}

						const defaultImport = node.getDefaultImport();
						if (defaultImport) {
							imports.set(defaultImport.getText(), {
								module,
								text: defaultImport.getText(),
								isDefault: true,
							});
						}
					}

					// // Write the source file for blocks only.
					sourceFilename = `__registry__/${framework.name}/${type}/${item.name}.tsx`;

					if (item.files) {
						const files = item.files.map((file) =>
							typeof file === "string"
								? { type: "registry:page", path: file }
								: file,
						);
						if (files.length) {
							sourceFilename = `src/__registry__/${framework.name}/${files[0].path}`;
						}
					}

					const sourcePath = path.join(process.cwd(), sourceFilename);
					if (!existsSync(sourcePath)) {
						await fs.mkdir(sourcePath, { recursive: true });
					}

					rimraf.sync(sourcePath);
					await fs.writeFile(sourcePath, sourceFile.getText());
				}

				let componentPath = `@repo/${framework.name}/${type}/${item.name}`;

				if (item.files) {
					const files = item.files.map((file) =>
						typeof file === "string"
							? { type: "registry:page", path: file }
							: file,
					);
					if (files.length) {
						componentPath = `@repo/${framework.name}/${files[0].path.slice(0, -4)}`;
					}
				}

				index += `
		"${item.name}": {
		name: "${item.name}",
		description: "${item.description ?? ""}",
		type: "${item.type}",
		registryDependencies: ${JSON.stringify(item.registryDependencies)},
		files: [${item.files?.map((file) => {
			const filePath = `../packages/${framework.name}/${
				typeof file === "string" ? file : file.path
			}`;
			const resolvedFilePath = path.resolve(filePath);
			return typeof file === "string"
				? `"${resolvedFilePath}"`
				: `{
			path: "${filePath}",
			type: "${file.type}",
			target: "${file.target ?? ""}"
		}`;
		})}],
		component: clientOnly(() => import("${componentPath}"), { lazy: true }),
		source: "${sourceFilename}",
		category: "${item.category ?? ""}",
		subcategory: "${item.subcategory ?? ""}",
		chunks: [${chunks.map(
			(chunk: {
				name: any;
				description: any;
				component: any;
				file: any;
				container: { className: any };
			}) => `{
			name: "${chunk.name}",
			description: "${chunk.description ?? "No description"}",
			component: ${chunk.component}
			file: "${chunk.file}",
			container: {
			className: "${chunk.container.className}"
			}
		}`,
		)}]
		},`;
			}
		}

		index += `
	},`;
	}

	index += `
  }
  `;

	// ----------------------------------------------------------------------------
	// Build registry/index.json.
	// ----------------------------------------------------------------------------
	const items = registry
		.filter((item) => ["registry:ui"].includes(item.type))
		.map((item) => {
			return {
				...item,
				files: item.files?.map((_file) => {
					const file =
						typeof _file === "string"
							? {
									path: _file,
									type: item.type,
								}
							: _file;

					return file;
				}),
			};
		});
	const registryJson = JSON.stringify(items, null, 2);
	if (!existsSync(path.join(REGISTRY_PATH))) {
		mkdirSync(path.join(REGISTRY_PATH), { recursive: true });
	}
	rimraf.sync(path.join(REGISTRY_PATH, "index.json"));
	await fs.writeFile(
		path.join(REGISTRY_PATH, "index.json"),
		registryJson,
		"utf8",
	);

	// Write style index.
	if (!existsSync(path.join(process.cwd(), "src/__registry__"))) {
		mkdirSync(path.join(process.cwd(), "src/__registry__"), {
			recursive: true,
		});
	}
	rimraf.sync(path.join(process.cwd(), "src/__registry__/index.ts"));
	await fs.writeFile(
		path.join(process.cwd(), "src/__registry__/index.ts"),
		index,
	);
}

try {
	const result = v.safeParse(registrySchema, registry);

	if (!result.success) {
		console.error(result.issues);
		process.exit(1);
	}

	await buildRegistry(result.output);

	console.log("âœ… Done!");
} catch (error) {
	console.error(error);
	process.exit(1);
}
